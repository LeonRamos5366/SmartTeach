| **Método**                      | **Descripción**                                                                 | **Complejidad Computacional** | **Explicación de la Complejidad**                                                                 | **Ejemplo Paso a Paso**                                                                 | **Video en YouTube** |
|----------------------------------|---------------------------------------------------------------------------------|-------------------------------|---------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|-----------------------|
| **Búsqueda Secuencial**          | Revisa cada elemento uno por uno hasta encontrar el que buscas.                 | O(n)                          | O(n) significa que el tiempo de búsqueda crece linealmente con el número de elementos.           | 1. Lista: [5, 3, 8, 4, 2] <br> 2. Buscar 4: <br> 3. Comparar 5 → no. <br> 4. Comparar 3 → no. <br> 5. Comparar 8 → no. <br> 6. Comparar 4 → ¡sí! Se encontró en la posición 3. | [Búsqueda Secuencial](https://www.youtube.com/watch?v=g4n2quTBci4) |
| **Búsqueda Binaria**             | Divide la lista en dos y busca en la mitad, repitiendo hasta encontrar el elemento. (Requiere lista ordenada). | O(log n)                     | O(log n) significa que el tiempo de búsqueda crece lentamente incluso si aumentas mucho el número de elementos. | 1. Lista ordenada: [2, 3, 4, 5, 8] <br> 2. Buscar 4: <br> 3. Comparar con el medio (4) → ¡sí! Se encontró en la posición 2. | [Búsqueda Binaria](https://www.youtube.com/watch?v=wAmu0Ly5ook) |
| **Búsqueda Hashing**             | Usa una función hash para convertir el valor a una posición en una tabla, permitiendo búsquedas rápidas. | O(1) promedio                 | O(1) significa que el tiempo de búsqueda es constante, independientemente del número de elementos. | 1. Tabla hash: [0: 5, 1: 3, 2: 8, 3: 4, 4: 2] <br> 2. Buscar 4: <br> 3. Calcular hash de 4 → posición 3. <br> 4. Encontrar 4 en la posición 3. | [Búsqueda Hashing](https://www.youtube.com/watch?v=sZcHb0XD2bI) |
| **Ordenamiento por Burbuja**     | Compara elementos adyacentes y los intercambia si están en el orden incorrecto. Se repite hasta que no hay más intercambios. | O(n²)                         | O(n²) significa que si tienes n elementos, el tiempo que toma el algoritmo crece cuadráticamente. | 1. Lista inicial: [5, 3, 8, 4, 2] <br> 2. Comparar 5 y 3 → intercambiar: [3, 5, 8, 4, 2] <br> 3. Comparar 5 y 8 → no intercambiar. <br> 4. Comparar 8 y 4 → intercambiar: [3, 5, 4, 8, 2] <br> 5. Comparar 8 y 2 → intercambiar: [3, 5, 4, 2, 8] <br> 6. Repetir hasta que la lista esté ordenada: [2, 3, 4, 5, 8] | [Ordenamiento por Burbuja](https://www.youtube.com/watch?v=nkPo48sHOyU) |
| **Ordenamiento por Inserción**    | Toma un elemento y lo coloca en la posición correcta en la parte ya ordenada de la lista. | O(n²)                         | O(n²) significa que el tiempo de ejecución también crece rápidamente con más elementos. | 1. Lista inicial: [5, 3, 8, 4, 2] <br> 2. Comenzar con el segundo elemento (3): [3, 5, 8, 4, 2] <br> 3. Tomar 8: ya está en su lugar. <br> 4. Tomar 4: mover 8 y 5 → [3, 4, 5, 8, 2] <br> 5. Tomar 2: mover 8, 5, 4 y 3 → [2, 3, 4, 5, 8] | [Ordenamiento por Inserción](https://www.youtube.com/watch?v=YamWum1Lwm8) |
| **Ordenamiento por Selección**    | Busca el elemento más pequeño y lo coloca al principio, luego repite con el resto de la lista. | O(n²)                         | Similar al burbuja, O(n²) significa que el tiempo de ejecución aumenta rápidamente con más elementos. | 1. Lista inicial: [5, 3, 8, 4, 2] <br> 2. Buscar el más pequeño (2) y colocarlo al principio: [2, 3, 8, 4, 5] <br> 3. Repetir con [3, 8, 4, 5]: buscar 3, ya está en su lugar. <br> 4. Buscar el más pequeño en [8, 4, 5] (4) y colocar: [2, 3, 4, 8, 5] <br> 5. Finalmente, ordenar [8, 5] → [2, 3, 4, 5, 8] | [Ordenamiento por Selección](https://www.youtube.com/watch?v=sQwCdFY7QtU) |
| **Ordenamiento con Árbol Binario** | Usa un árbol binario para organizar los elementos, luego los extrae en orden. | O(n log n)                   | O(n log n) significa que el tiempo de ejecución es más eficiente que O(n²) para listas grandes. | 1. Insertar elementos en el árbol: [5, 3, 8, 4, 2] <br> 2. Extraer en orden: [2, 3, 4, 5, 8] | [Ordenamiento con Árbol Binario](https://www.youtube.com/watch?v=Jo2euX89Oz8) |
| **Ordenamiento Shell**            | Es una mejora del ordenamiento por inserción que permite comparar elementos que están lejos entre sí. | O(n log n)                   | O(n log n) significa que es más eficiente que O(n²) y se adapta bien a listas grandes. | 1. Lista inicial: [5, 3, 8, 4, 2] <br> 2. Comparar elementos separados por un intervalo (h) y ordenar. <br> 3. Reducir h y repetir hasta que h sea
| [Ordenamiento Shell](https://www.youtube.com/watch?v=bJ-LWnpyx6s) 
